<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sequoia: UnitTestFramework/FreeCheckers.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sequoia
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_91ebe98c49e7ebe08769d398871963c8.html">UnitTestFramework</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">FreeCheckers.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Free functions for performing checks, together with the 'checker' class template which wraps them.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_free_checkers_details_8hpp_source.html">FreeCheckersDetails.hpp</a>&quot;</code><br />
</div>
<p><a href="_free_checkers_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1unit__testing_1_1detailed__equality__checker.html">sequoia::unit_testing::detailed_equality_checker&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class template, specializations of which implement detailed comparison of two instantiations of T;  <a href="structsequoia_1_1unit__testing_1_1detailed__equality__checker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1unit__testing_1_1equivalence__checker.html">sequoia::unit_testing::equivalence_checker&lt; T, Us &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class template, specializations of which implement comparision of two equivalent types;  <a href="structsequoia_1_1unit__testing_1_1equivalence__checker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1unit__testing_1_1weak__equivalence__checker.html">sequoia::unit_testing::weak_equivalence_checker&lt; T, Us &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class template, specializations of which implement comparision of two weakly equivalent types;  <a href="structsequoia_1_1unit__testing_1_1weak__equivalence__checker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1unit__testing_1_1equality__tag.html">sequoia::unit_testing::equality_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1unit__testing_1_1equivalence__tag.html">sequoia::unit_testing::equivalence_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1unit__testing_1_1weak__equivalence__tag.html">sequoia::unit_testing::weak_equivalence_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1unit__testing_1_1serializer.html">sequoia::unit_testing::serializer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize this struct template to provide custom serialization of a given class.  <a href="structsequoia_1_1unit__testing_1_1serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1unit__testing_1_1type__info.html">sequoia::unit_testing::type_info&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize this struct template to customize the way in which type info is generated for a given class; this is particularly useful for class templates where standard de-mangling may be hard to read!  <a href="structsequoia_1_1unit__testing_1_1type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsequoia_1_1unit__testing_1_1checker.html">sequoia::unit_testing::checker&lt; Mode, Extenders &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes elementary check methods, with the option to plug in arbitrary Extenders to compose functionality.  <a href="classsequoia_1_1unit__testing_1_1checker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0cb673303b9b2ed82705a527beaebb07"><td class="memTemplParams" colspan="2"><a id="a0cb673303b9b2ed82705a527beaebb07"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0cb673303b9b2ed82705a527beaebb07"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::to_string</b> (const T &amp;value)</td></tr>
<tr class="separator:a0cb673303b9b2ed82705a527beaebb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3a9e38e9072a17007508624684b9b6"><td class="memTemplParams" colspan="2"><a id="a5b3a9e38e9072a17007508624684b9b6"></a>
template&lt;class T , class... U&gt; </td></tr>
<tr class="memitem:a5b3a9e38e9072a17007508624684b9b6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::add_type_info</b> (std::string_view description)</td></tr>
<tr class="separator:a5b3a9e38e9072a17007508624684b9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee54bbd68ce78c773346abb03d7150e"><td class="memTemplParams" colspan="2">template&lt;test_mode Mode, class T &gt; </td></tr>
<tr class="memitem:a9ee54bbd68ce78c773346abb03d7150e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_free_checkers_8hpp.html#a9ee54bbd68ce78c773346abb03d7150e">sequoia::unit_testing::dispatch_check</a> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, equality_tag, const T &amp;value, const T &amp;prediction)</td></tr>
<tr class="memdesc:a9ee54bbd68ce78c773346abb03d7150e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The workhorse of equality checking, which takes responsibility for reflecting upon types and then dispatching, appropriately.  <a href="_free_checkers_8hpp.html#a9ee54bbd68ce78c773346abb03d7150e">More...</a><br /></td></tr>
<tr class="separator:a9ee54bbd68ce78c773346abb03d7150e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaee9a1a39cb89c17b77e2c6043c59c5"><td class="memTemplParams" colspan="2">template&lt;test_mode Mode, class T , class S , class... U&gt; </td></tr>
<tr class="memitem:aeaee9a1a39cb89c17b77e2c6043c59c5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_free_checkers_8hpp.html#aeaee9a1a39cb89c17b77e2c6043c59c5">sequoia::unit_testing::dispatch_check</a> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, equivalence_tag, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="memdesc:aeaee9a1a39cb89c17b77e2c6043c59c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The workhorse for equivalence checking.  <a href="_free_checkers_8hpp.html#aeaee9a1a39cb89c17b77e2c6043c59c5">More...</a><br /></td></tr>
<tr class="separator:aeaee9a1a39cb89c17b77e2c6043c59c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d140a3cb27dbd1caeb317a6d92297a6"><td class="memTemplParams" colspan="2">template&lt;test_mode Mode, class T , class S , class... U&gt; </td></tr>
<tr class="memitem:a4d140a3cb27dbd1caeb317a6d92297a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_free_checkers_8hpp.html#a4d140a3cb27dbd1caeb317a6d92297a6">sequoia::unit_testing::dispatch_check</a> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, weak_equivalence_tag, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="memdesc:a4d140a3cb27dbd1caeb317a6d92297a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The workhorse for weak equivalence checking.  <a href="_free_checkers_8hpp.html#a4d140a3cb27dbd1caeb317a6d92297a6">More...</a><br /></td></tr>
<tr class="separator:a4d140a3cb27dbd1caeb317a6d92297a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be0954c19b657355bd318177d9fdfe7"><td class="memTemplParams" colspan="2"><a id="a8be0954c19b657355bd318177d9fdfe7"></a>
template&lt;test_mode Mode, class T &gt; </td></tr>
<tr class="memitem:a8be0954c19b657355bd318177d9fdfe7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::check_equality</b> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, const T &amp;value, const T &amp;prediction)</td></tr>
<tr class="separator:a8be0954c19b657355bd318177d9fdfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef85ae58a1c0b7e31abc49c33e9250a"><td class="memTemplParams" colspan="2"><a id="a8ef85ae58a1c0b7e31abc49c33e9250a"></a>
template&lt;test_mode Mode, class T , class S , class... U&gt; </td></tr>
<tr class="memitem:a8ef85ae58a1c0b7e31abc49c33e9250a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::check_equivalence</b> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="separator:a8ef85ae58a1c0b7e31abc49c33e9250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20480275f30997c779e0856554f1bce"><td class="memTemplParams" colspan="2"><a id="ac20480275f30997c779e0856554f1bce"></a>
template&lt;test_mode Mode, class T , class S , class... U&gt; </td></tr>
<tr class="memitem:ac20480275f30997c779e0856554f1bce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::check_weak_equivalence</b> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="separator:ac20480275f30997c779e0856554f1bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b4b34ad57a97d8cf9d9bb8a0a09bfc"><td class="memTemplParams" colspan="2"><a id="a42b4b34ad57a97d8cf9d9bb8a0a09bfc"></a>
template&lt;test_mode Mode&gt; </td></tr>
<tr class="memitem:a42b4b34ad57a97d8cf9d9bb8a0a09bfc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::check</b> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, const bool value)</td></tr>
<tr class="separator:a42b4b34ad57a97d8cf9d9bb8a0a09bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c446d27e2df5cc8898d4484665aca79"><td class="memTemplParams" colspan="2"><a id="a0c446d27e2df5cc8898d4484665aca79"></a>
template&lt;class E , test_mode Mode, class Fn &gt; </td></tr>
<tr class="memitem:a0c446d27e2df5cc8898d4484665aca79"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::check_exception_thrown</b> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, Fn &amp;&amp;function)</td></tr>
<tr class="separator:a0c446d27e2df5cc8898d4484665aca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b3951c1a9e9bf7bc1f1a41bbe807c8"><td class="memTemplParams" colspan="2"><a id="aa3b3951c1a9e9bf7bc1f1a41bbe807c8"></a>
template&lt;test_mode Mode, class Iter , class PredictionIter &gt; </td></tr>
<tr class="memitem:aa3b3951c1a9e9bf7bc1f1a41bbe807c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::check_range</b> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, Iter first, Iter last, PredictionIter predictionFirst, PredictionIter predictionLast)</td></tr>
<tr class="separator:aa3b3951c1a9e9bf7bc1f1a41bbe807c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7aa7fd62e5103817b50758487ac4a56"><td class="memTemplParams" colspan="2"><a id="af7aa7fd62e5103817b50758487ac4a56"></a>
template&lt;test_mode Mode, class Iter , class PredictionIter &gt; </td></tr>
<tr class="memitem:af7aa7fd62e5103817b50758487ac4a56"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::check_range_equivalence</b> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, Iter first, Iter last, PredictionIter predictionFirst, PredictionIter predictionLast)</td></tr>
<tr class="separator:af7aa7fd62e5103817b50758487ac4a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8babc4c121ac3064d5e5e21b02fbf3c9"><td class="memTemplParams" colspan="2"><a id="a8babc4c121ac3064d5e5e21b02fbf3c9"></a>
template&lt;test_mode Mode, class Iter , class PredictionIter &gt; </td></tr>
<tr class="memitem:a8babc4c121ac3064d5e5e21b02fbf3c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::check_range_weak_equivalence</b> (std::string_view description, unit_test_logger&lt; Mode &gt; &amp;logger, Iter first, Iter last, PredictionIter predictionFirst, PredictionIter predictionLast)</td></tr>
<tr class="separator:a8babc4c121ac3064d5e5e21b02fbf3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2289c84695de436d903d794eeff0aad2"><td class="memTemplParams" colspan="2"><a id="a2289c84695de436d903d794eeff0aad2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2289c84695de436d903d794eeff0aad2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::has_equivalence_checker_v</b> {class_template_is_instantiable_v&lt;equivalence_checker, T&gt;}</td></tr>
<tr class="separator:a2289c84695de436d903d794eeff0aad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42b58ca5e2b0e215be01a60514fd45e"><td class="memTemplParams" colspan="2"><a id="af42b58ca5e2b0e215be01a60514fd45e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af42b58ca5e2b0e215be01a60514fd45e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::has_weak_equivalence_checker_v</b> {class_template_is_instantiable_v&lt;weak_equivalence_checker, T&gt;}</td></tr>
<tr class="separator:af42b58ca5e2b0e215be01a60514fd45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629694a17052c462e2b1fea640171569"><td class="memTemplParams" colspan="2"><a id="a629694a17052c462e2b1fea640171569"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a629694a17052c462e2b1fea640171569"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::unit_testing::has_detailed_equality_checker_v</b> {class_template_is_instantiable_v&lt;detailed_equality_checker, T&gt;}</td></tr>
<tr class="separator:a629694a17052c462e2b1fea640171569"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Free functions for performing checks, together with the 'checker' class template which wraps them. </p>
<p>Given a type, T, any reasonable testing framework must provide a mechanism for checking whether or not two instances of T are, in some sense, the same. If the type implements operator== then it is natural to utilize this. However, there is much more to the story. First of all, if this check fails then, in order to be useful, there must be some way of serializing the state of T. This may be done by specializing the class template string_maker for cases where operator&lt;&lt; is not appropriately overloaded.</p>
<p>However, there is an alternative which may be superior. Consider trying to implement vector. This class has various const accessors suggesting that, if operator== returns false, then the accessors can be used to probe the exact nature of the inequality. To this end, a class template detailed_equality_checker is defined. Specializations perform a detailed check of the equality of the state of two supposedly equal instance of a class. Note that there is no need for the detailed_equality_checker to include checks of operator== or operator!=, since these will be done, regardless. Indeed, the detailed_equality_checker will be triggered independently of whether operator== fails since either the latter or the accesors may have bugs and introducing unnecessary dependencies would reduce the fidelity of the testing framewrok.</p>
<p>If a detailed_equality_checker is supplied, then compile-time logic will ignore any attempt to serialize objects of type T. Typically, clients may expect a notification that operator== has returned false (and, for consistency, notification that operator!= has returned true). There will then be a series of subsequent checks which will reveal the precise nature of the failure. For example, for vectors, one will be told whether the sizes differ and, if not, the element which is causing the difference between the two supposedly equal instances. If the vector holds a user-defined type then, so long as this has its own detailed_equality_checker, the process will continue until a type is reached without a detailed_equality_checker; typically this will be a sufficiently simple type that serialization is the appropriate solution (as is the case for may built-in types).</p>
<p>Suppose a client wishes to compare instance of some_container&lt;T&gt;. If some_container has a specialization of detailed_equality_checker then this will be used; if it does not then reflection is used to determine if some_container overloads begin and end. If so, then it is treated as a range and all that is required is to implement a detailed_equality_checker for T (unless serialization is prefered). If some_container is user-defined, it is wisest to provide an overload of the detailed_equality_checker. However, if the container is part of std, it is probably safe to assume it works correctly and so instead effort can be directed focused on T.</p>
<p>With this in mind, imagine creating a container. One of the first things one may wish to do is to check that it is correctly initialized. It would be a mistake to use the detailed_equality_checker for this since, to do so a second, identical instance would need to be created. This is circular and prone to false positives. Conseuqently, the testing framework also defines a pair of class templates that complement detailed_equality_checker: equivalence_checker and weak_equivalence_checker. We may consider a value for std::vector to be equivalent to an initializer_list in the sense that they hold (at the relevant point of the program) the same elements. Thus, a specialization equivalence_checker&lt;vector, initializer_list&gt; is supplied. Of course, there is more to a vector than the values it holds: there is the entire allocator framework too. In this case, however, it is not part of the logical structure and, indeed, the state of the allocator is not considered in vector::operator==. Thus it is philosphically reasonable to consider equivalence of vector and initializer_list. However, sometimes is is useful to check the equivalence of the state of an instance of T to a proper subset of the logical state of an instance of some S. For this purpose, the class template weak_equivalence_checker is supplied.</p>
<p>Both the equivalence_checker and its weak counterpart can be fed &gt;=2 template type arguments. While for a vector we would just feed in two types (vector and initializer_list), in some cases we may need more. For example, a graph has both nodes and edges and so a graph may be consdidered equivalent to two types representing these structures. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="file_a9ee54bbd68ce78c773346abb03d7150e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a9ee54bbd68ce78c773346abb03d7150e">&#9670;&nbsp;</a></span>dispatch_check() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;test_mode Mode, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sequoia::unit_testing::dispatch_check </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsequoia_1_1unit__testing_1_1unit__test__logger.html">unit_test_logger</a>&lt; Mode &gt; &amp;&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsequoia_1_1unit__testing_1_1equality__tag.html">equality_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>prediction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The workhorse of equality checking, which takes responsibility for reflecting upon types and then dispatching, appropriately. </p>
<p>The next three functions form an overload set, dedicated to appropiately dispatching requests to check equality, equivalence and weak equivalence. This set may be supplemented by extenders of the testing framework, see <a class="el" href="_fuzzy_test_core_8hpp.html" title="Extension of unit testing framework for fuzzy testing.">FuzzyTestCore.hpp</a> for an example.</p>
<p>The input type, T, must either be equality comparable or possess a detailed_equality_checker, or both. Generally, it will be the case that T does indeed overload operator==; generally anything beyond the simplest user-defined types should be furnished with a detailed_equality_checker. </p>

</div>
</div>
<a id="file_aeaee9a1a39cb89c17b77e2c6043c59c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_aeaee9a1a39cb89c17b77e2c6043c59c5">&#9670;&nbsp;</a></span>dispatch_check() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;test_mode Mode, class T , class S , class... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sequoia::unit_testing::dispatch_check </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsequoia_1_1unit__testing_1_1unit__test__logger.html">unit_test_logger</a>&lt; Mode &gt; &amp;&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsequoia_1_1unit__testing_1_1equivalence__tag.html">equivalence_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;...&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The workhorse for equivalence checking. </p>
<p>This function will reflect on whether an appropriate specialization of equivalence_checker exists. If so, it will be used and if not it will attempt to interpret T as a range. Only if this fails then a static assertion will terminate compilation. </p>

</div>
</div>
<a id="file_a4d140a3cb27dbd1caeb317a6d92297a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a4d140a3cb27dbd1caeb317a6d92297a6">&#9670;&nbsp;</a></span>dispatch_check() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;test_mode Mode, class T , class S , class... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sequoia::unit_testing::dispatch_check </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsequoia_1_1unit__testing_1_1unit__test__logger.html">unit_test_logger</a>&lt; Mode &gt; &amp;&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsequoia_1_1unit__testing_1_1weak__equivalence__tag.html">weak_equivalence_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;...&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The workhorse for weak equivalence checking. </p>
<p>This function will reflect on whether an appropriate specialization of weak_equivalence_checker exists. If so, it will be used and if not it will attempt to interpret T as a range. Only if this fails then a static assertion will terminate compilation. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
