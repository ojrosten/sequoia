<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sequoia: sequoia Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sequoia
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sequoia Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Useful specializations for the class template detailed_equality_checker.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1class__template__is__instantiable.html">class_template_is_instantiable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1class__template__is__instantiable_3_01std_1_1void__t_3_01decltype_07_t_3_01_arg6c1ebffd7bb68464f4b8a206e26f5c17.html">class_template_is_instantiable&lt; std::void_t&lt; decltype(T&lt; Args... &gt;{})&gt;, T, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1dependent__false.html">dependent_false</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1has__allocator__type.html">has_allocator_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1has__allocator__type_3_01_t_00_01std_1_1void__t_3_01typename_01_t_1_1allocator__type_01_4_01_4.html">has_allocator_type&lt; T, std::void_t&lt; typename T::allocator_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1has__default__constructor.html">has_default_constructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1has__default__constructor_3_01_t_00_01std_1_1void__t_3_01decltype_07new_01_t_02_03_08_4_01_4.html">has_default_constructor&lt; T, std::void_t&lt; decltype(new T{})&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1has__move__only__semantics.html">has_move_only_semantics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1has__partitions__allocator__type.html">has_partitions_allocator_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1has__partitions__allocator__type_3_01_t_00_01std_1_1void__t_3_01typename_01_t_1e9883d4fc87449e8a5e0ea8fe637c866.html">has_partitions_allocator_type&lt; T, std::void_t&lt; typename T::partitions_allocator_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1has__regular__semantics.html">has_regular_semantics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__allocator.html">is_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__allocator_3_01_t_00_01std_1_1void__t_3_01decltype_07std_1_1declval_3_01_t_0049427f835b11d7e9108db54da2d0fb5.html">is_allocator&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().allocate(0))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__base__of__head.html">is_base_of_head</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__const__pointer.html">is_const_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__const__pointer_3_01const_01_t_01_5_01_4.html">is_const_pointer&lt; const T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__const__pointer_3_01const_01_t_01_5const_01_4.html">is_const_pointer&lt; const T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__const__reference.html">is_const_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__container.html">is_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__container_3_01_t_00_01std_1_1void__t_3_01decltype_07std_1_1begin_07std_1_1d4fb032eb1b162f4553d62c2880c12d64.html">is_container&lt; T, std::void_t&lt; decltype(std::begin(std::declval&lt; T &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__equal__to__comparable.html">is_equal_to_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__equal__to__comparable_3_01_t_00_01std_1_1void__t_3_01decltype_07std_1_1decl63d4f1b7534d2575e3af6c21dc9e9b10.html">is_equal_to_comparable&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__not__equal__to__comparable.html">is_not_equal_to_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__not__equal__to__comparable_3_01_t_00_01std_1_1void__t_3_01decltype_07_07stda046c42576a8423b543392105dd6eb81.html">is_not_equal_to_comparable&lt; T, std::void_t&lt; decltype((std::declval&lt; T &gt;() !=std::declval&lt; T &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__orderable.html">is_orderable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__serializable.html">is_serializable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1resolve__to__copy__constructor.html">resolve_to_copy_constructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1variadic__traits.html">variadic_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1variadic__traits_3_4.html">variadic_traits&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__serializable_3_01_t_00_01std_1_1void__t_3_01decltype_07makelval_3_01std_1_19016cd01381d4fb3ea6228994b72d0d7.html">void_t&lt; decltype(makelval&lt; std::stringstream &gt;()&lt;&lt; std::declval&lt; T &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsequoia_1_1is__orderable_3_01_t_00_01std_1_1void__t_3_01decltype_07std_1_1declval_3_01_t_069c35a3fc838b4f622235a8c36928d18.html">void_t&lt; decltype(std::declval&lt; T &gt;()&lt; std::declval&lt; T &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad72ca893bee0f43f3008270a189ce299"><td class="memTemplParams" colspan="2"><a id="ad72ca893bee0f43f3008270a189ce299"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad72ca893bee0f43f3008270a189ce299"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_partitions_allocator_type_t</b> = typename <a class="el" href="structsequoia_1_1has__partitions__allocator__type.html">has_partitions_allocator_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ad72ca893bee0f43f3008270a189ce299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a651440a60f865d5552ec56efa5cc6"><td class="memTemplParams" colspan="2"><a id="a37a651440a60f865d5552ec56efa5cc6"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a37a651440a60f865d5552ec56efa5cc6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_base_of_head_t</b> = typename <a class="el" href="structsequoia_1_1is__base__of__head.html">is_base_of_head</a>&lt; T, Args... &gt;::type</td></tr>
<tr class="separator:a37a651440a60f865d5552ec56efa5cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdac72499a3714276776ed639e802a91"><td class="memTemplParams" colspan="2"><a id="abdac72499a3714276776ed639e802a91"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:abdac72499a3714276776ed639e802a91"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>resolve_to_copy_constructor_t</b> = typename <a class="el" href="structsequoia_1_1resolve__to__copy__constructor.html">resolve_to_copy_constructor</a>&lt; T, Args... &gt;::type</td></tr>
<tr class="separator:abdac72499a3714276776ed639e802a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60500b8aa430563fe9e4babc7ca98ede"><td class="memTemplParams" colspan="2"><a id="a60500b8aa430563fe9e4babc7ca98ede"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a60500b8aa430563fe9e4babc7ca98ede"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_const_pointer_t</b> = typename <a class="el" href="structsequoia_1_1is__const__pointer.html">is_const_pointer</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a60500b8aa430563fe9e4babc7ca98ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2006d10da9429a0220e218bb90c57502"><td class="memTemplParams" colspan="2"><a id="a2006d10da9429a0220e218bb90c57502"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2006d10da9429a0220e218bb90c57502"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_const_reference_t</b> = typename <a class="el" href="structsequoia_1_1is__const__reference.html">is_const_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a2006d10da9429a0220e218bb90c57502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310ef81e26eee49adcbdb99417830613"><td class="memTemplParams" colspan="2"><a id="a310ef81e26eee49adcbdb99417830613"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a310ef81e26eee49adcbdb99417830613"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_orderable_t</b> = typename <a class="el" href="structsequoia_1_1is__orderable.html">is_orderable</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a310ef81e26eee49adcbdb99417830613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007e47c4a8826bfbea3179020ab1d04c"><td class="memTemplParams" colspan="2"><a id="a007e47c4a8826bfbea3179020ab1d04c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a007e47c4a8826bfbea3179020ab1d04c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_equal_to_comparable_t</b> = typename <a class="el" href="structsequoia_1_1is__equal__to__comparable.html">is_equal_to_comparable</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a007e47c4a8826bfbea3179020ab1d04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315f5c1ec9aaa85576317084c6701f3c"><td class="memTemplParams" colspan="2"><a id="a315f5c1ec9aaa85576317084c6701f3c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a315f5c1ec9aaa85576317084c6701f3c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_not_equal_to_comparable_t</b> = typename <a class="el" href="structsequoia_1_1is__not__equal__to__comparable.html">is_not_equal_to_comparable</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a315f5c1ec9aaa85576317084c6701f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2279516b30423aeb69f474a7581a4d"><td class="memTemplParams" colspan="2"><a id="afb2279516b30423aeb69f474a7581a4d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afb2279516b30423aeb69f474a7581a4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_container_t</b> = typename <a class="el" href="structsequoia_1_1is__container.html">is_container</a>&lt; T &gt;::type</td></tr>
<tr class="separator:afb2279516b30423aeb69f474a7581a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bce7245f029e15a09b1ba0750ab183"><td class="memTemplParams" colspan="2"><a id="a34bce7245f029e15a09b1ba0750ab183"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a34bce7245f029e15a09b1ba0750ab183"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_allocator_t</b> = typename <a class="el" href="structsequoia_1_1is__allocator.html">is_allocator</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a34bce7245f029e15a09b1ba0750ab183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779bb3cfa56320ef25d8aac15ff7fd2d"><td class="memTemplParams" colspan="2"><a id="a779bb3cfa56320ef25d8aac15ff7fd2d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a779bb3cfa56320ef25d8aac15ff7fd2d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_serializable_t</b> = typename <a class="el" href="structsequoia_1_1is__serializable.html">is_serializable</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a779bb3cfa56320ef25d8aac15ff7fd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac3f881b09bf8a51f9b184f3b180e17"><td class="memTemplParams" colspan="2"><a id="a3ac3f881b09bf8a51f9b184f3b180e17"></a>
template&lt;template&lt; class... &gt; class T, class... Args&gt; </td></tr>
<tr class="memitem:a3ac3f881b09bf8a51f9b184f3b180e17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>class_template_is_instantiable_t</b> = typename <a class="el" href="structsequoia_1_1class__template__is__instantiable.html">class_template_is_instantiable</a>&lt; std::void_t&lt;&gt;, T, Args... &gt;::type</td></tr>
<tr class="separator:a3ac3f881b09bf8a51f9b184f3b180e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5326b4a9577359d0741fde3adf7edda8"><td class="memTemplParams" colspan="2"><a id="a5326b4a9577359d0741fde3adf7edda8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5326b4a9577359d0741fde3adf7edda8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_regular_semantics_t</b> = typename <a class="el" href="structsequoia_1_1has__regular__semantics.html">has_regular_semantics</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a5326b4a9577359d0741fde3adf7edda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1fe81e0125efcc50da9b1deacf422e"><td class="memTemplParams" colspan="2"><a id="a6b1fe81e0125efcc50da9b1deacf422e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6b1fe81e0125efcc50da9b1deacf422e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_move_only_semantics_t</b> = typename <a class="el" href="structsequoia_1_1has__move__only__semantics.html">has_move_only_semantics</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a6b1fe81e0125efcc50da9b1deacf422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5be202fb6aa4b72db6d1dae1d1989a"><td class="memTemplParams" colspan="2"><a id="a7a5be202fb6aa4b72db6d1dae1d1989a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7a5be202fb6aa4b72db6d1dae1d1989a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_default_constructor_t</b> = typename <a class="el" href="structsequoia_1_1has__default__constructor.html">has_default_constructor</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a7a5be202fb6aa4b72db6d1dae1d1989a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7915fff8b9d6a00e498e70108ac6b8f5"><td class="memTemplParams" colspan="2"><a id="a7915fff8b9d6a00e498e70108ac6b8f5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7915fff8b9d6a00e498e70108ac6b8f5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_allocator_type_t</b> = typename <a class="el" href="structsequoia_1_1has__allocator__type.html">has_allocator_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a7915fff8b9d6a00e498e70108ac6b8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aff5a8fa509c290cb9cbeaf0600391f01"><td class="memTemplParams" colspan="2"><a id="aff5a8fa509c290cb9cbeaf0600391f01"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aff5a8fa509c290cb9cbeaf0600391f01"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (T &amp;a, T &amp;b)</td></tr>
<tr class="separator:aff5a8fa509c290cb9cbeaf0600391f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c76b567c9b9db3ea221ebf5aa5174a9"><td class="memTemplParams" colspan="2"><a id="a3c76b567c9b9db3ea221ebf5aa5174a9"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a3c76b567c9b9db3ea221ebf5aa5174a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iter_swap</b> (Iter a, Iter b)</td></tr>
<tr class="separator:a3c76b567c9b9db3ea221ebf5aa5174a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f92f99d98834b387c91364ed27945db"><td class="memTemplParams" colspan="2"><a id="a6f92f99d98834b387c91364ed27945db"></a>
template&lt;class FwdIter , class Comparer  = std::less&lt;std::decay_t&lt;decltype(*FwdIter())&gt;&gt;&gt; </td></tr>
<tr class="memitem:a6f92f99d98834b387c91364ed27945db"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bubble_up</b> (FwdIter begin, FwdIter current, Comparer comp=Comparer{})</td></tr>
<tr class="separator:a6f92f99d98834b387c91364ed27945db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263ce9cc9773bd10d1d4f798f9f09d52"><td class="memTemplParams" colspan="2"><a id="a263ce9cc9773bd10d1d4f798f9f09d52"></a>
template&lt;class FwdIter , class Comparer  = std::less&lt;std::decay_t&lt;decltype(*FwdIter())&gt;&gt;&gt; </td></tr>
<tr class="memitem:a263ce9cc9773bd10d1d4f798f9f09d52"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bubble_down</b> (FwdIter begin, FwdIter current, FwdIter end, Comparer comp=Comparer{})</td></tr>
<tr class="separator:a263ce9cc9773bd10d1d4f798f9f09d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ac8e287bc135a4097d4fd94c1e9461"><td class="memTemplParams" colspan="2"><a id="a11ac8e287bc135a4097d4fd94c1e9461"></a>
template&lt;class FwdIter , class Comparer  = std::less&lt;std::decay_t&lt;decltype(*FwdIter())&gt;&gt;&gt; </td></tr>
<tr class="memitem:a11ac8e287bc135a4097d4fd94c1e9461"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_heap</b> (FwdIter begin, FwdIter end, Comparer comp=Comparer{})</td></tr>
<tr class="separator:a11ac8e287bc135a4097d4fd94c1e9461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f4e9bb50033d7889996c5866d3c489"><td class="memTemplParams" colspan="2"><a id="a85f4e9bb50033d7889996c5866d3c489"></a>
template&lt;class FwdIter , class Comparer  = std::less&lt;std::decay_t&lt;decltype(*FwdIter())&gt;&gt;&gt; </td></tr>
<tr class="memitem:a85f4e9bb50033d7889996c5866d3c489"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (FwdIter begin, FwdIter end, Comparer comp=Comparer{})</td></tr>
<tr class="separator:a85f4e9bb50033d7889996c5866d3c489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7494324a9943fe3cb0da375acf4a1587"><td class="memTemplParams" colspan="2"><a id="a7494324a9943fe3cb0da375acf4a1587"></a>
template&lt;class ForwardIt &gt; </td></tr>
<tr class="memitem:a7494324a9943fe3cb0da375acf4a1587"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIt&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rotate</b> (ForwardIt first, ForwardIt n_first, ForwardIt last)</td></tr>
<tr class="separator:a7494324a9943fe3cb0da375acf4a1587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4fe271be1a66cb822625d3e8e49a96"><td class="memTemplParams" colspan="2"><a id="a9e4fe271be1a66cb822625d3e8e49a96"></a>
template&lt;class FwdIter , class Comparer  = std::equal_to&lt;std::decay_t&lt;decltype(*FwdIter())&gt;&gt;&gt; </td></tr>
<tr class="memitem:a9e4fe271be1a66cb822625d3e8e49a96"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cluster</b> (FwdIter begin, FwdIter end, Comparer comp=Comparer{})</td></tr>
<tr class="separator:a9e4fe271be1a66cb822625d3e8e49a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6199e7a0752808fae2c6dffa02dfb10"><td class="memTemplParams" colspan="2"><a id="ac6199e7a0752808fae2c6dffa02dfb10"></a>
template&lt;class FwdIter , class T , class Comparer  = std::less&lt;std::decay_t&lt;decltype(*FwdIter())&gt;&gt;&gt; </td></tr>
<tr class="memitem:ac6199e7a0752808fae2c6dffa02dfb10"><td class="memTemplItemLeft" align="right" valign="top">constexpr FwdIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (FwdIter begin, FwdIter end, const T &amp;val, Comparer comp=Comparer{})</td></tr>
<tr class="separator:ac6199e7a0752808fae2c6dffa02dfb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06248f773be025dcd2695fa1b0cde8c6"><td class="memTemplParams" colspan="2"><a id="a06248f773be025dcd2695fa1b0cde8c6"></a>
template&lt;class FwdIter , class T , class Comparer  = std::less&lt;std::decay_t&lt;decltype(*FwdIter())&gt;&gt;&gt; </td></tr>
<tr class="memitem:a06248f773be025dcd2695fa1b0cde8c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr FwdIter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (FwdIter begin, FwdIter end, const T &amp;val, Comparer comp=Comparer{})</td></tr>
<tr class="separator:a06248f773be025dcd2695fa1b0cde8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ad0504b8777477cf4d002c5897466"><td class="memTemplParams" colspan="2"><a id="ab79ad0504b8777477cf4d002c5897466"></a>
template&lt;class FwdIter , class T , class Comparer  = std::less&lt;std::decay_t&lt;decltype(*FwdIter())&gt;&gt;&gt; </td></tr>
<tr class="memitem:ab79ad0504b8777477cf4d002c5897466"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; FwdIter, FwdIter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (FwdIter begin, FwdIter end, const T &amp;val, Comparer comp=Comparer{})</td></tr>
<tr class="separator:ab79ad0504b8777477cf4d002c5897466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad446f3b790daab9e8d01ea2bdb80ccd5"><td class="memTemplParams" colspan="2"><a id="ad446f3b790daab9e8d01ea2bdb80ccd5"></a>
template&lt;class InputIt1 , class InputIt2 &gt; </td></tr>
<tr class="memitem:ad446f3b790daab9e8d01ea2bdb80ccd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (InputIt1 first1, InputIt2 last1, InputIt2 first2, InputIt2 last2)</td></tr>
<tr class="separator:ad446f3b790daab9e8d01ea2bdb80ccd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6257799193c895fb0382fb21adf4ddb5"><td class="memTemplParams" colspan="2"><a id="a6257799193c895fb0382fb21adf4ddb5"></a>
template&lt;class PartitionedData , class Pred , class Index  = typename PartitionedData::index_type&gt; </td></tr>
<tr class="memitem:a6257799193c895fb0382fb21adf4ddb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_from_partition_if</b> (PartitionedData &amp;data, const Index partitionIndex, Pred pred)</td></tr>
<tr class="separator:a6257799193c895fb0382fb21adf4ddb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e75722e76f1fcba4bbc80e2ee983e"><td class="memTemplParams" colspan="2"><a id="a774e75722e76f1fcba4bbc80e2ee983e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a774e75722e76f1fcba4bbc80e2ee983e"><td class="memTemplItemLeft" align="right" valign="top">std::add_lvalue_reference_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makelval</b> () noexcept</td></tr>
<tr class="separator:a774e75722e76f1fcba4bbc80e2ee983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a735ae6b5842f10d3e906bab8087d8c92"><td class="memTemplParams" colspan="2"><a id="a735ae6b5842f10d3e906bab8087d8c92"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a735ae6b5842f10d3e906bab8087d8c92"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_partitions_allocator_type_v</b> {<a class="el" href="structsequoia_1_1has__partitions__allocator__type.html">has_partitions_allocator_type</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:a735ae6b5842f10d3e906bab8087d8c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51063e2718ac15a1370456e1fee5200a"><td class="memTemplParams" colspan="2"><a id="a51063e2718ac15a1370456e1fee5200a"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a51063e2718ac15a1370456e1fee5200a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_base_of_head_v</b> {<a class="el" href="structsequoia_1_1is__base__of__head.html">is_base_of_head</a>&lt;T, Args...&gt;::value}</td></tr>
<tr class="separator:a51063e2718ac15a1370456e1fee5200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefa844439e1fc98b7be88f4712a90ba"><td class="memTemplParams" colspan="2"><a id="adefa844439e1fc98b7be88f4712a90ba"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:adefa844439e1fc98b7be88f4712a90ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>resolve_to_copy_constructor_v</b> {<a class="el" href="structsequoia_1_1resolve__to__copy__constructor.html">resolve_to_copy_constructor</a>&lt;T, Args...&gt;::value}</td></tr>
<tr class="separator:adefa844439e1fc98b7be88f4712a90ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae64f8f899f2c4dfb6f63b3f6cffd1d"><td class="memTemplParams" colspan="2"><a id="a7ae64f8f899f2c4dfb6f63b3f6cffd1d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7ae64f8f899f2c4dfb6f63b3f6cffd1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_const_pointer_v</b> {<a class="el" href="structsequoia_1_1is__const__pointer.html">is_const_pointer</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:a7ae64f8f899f2c4dfb6f63b3f6cffd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4197082ae7c0daad3d37de45e53dc281"><td class="memTemplParams" colspan="2"><a id="a4197082ae7c0daad3d37de45e53dc281"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4197082ae7c0daad3d37de45e53dc281"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_const_reference_v</b> {<a class="el" href="structsequoia_1_1is__const__reference.html">is_const_reference</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:a4197082ae7c0daad3d37de45e53dc281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c8e1665a381bfbb38307d296887e62"><td class="memTemplParams" colspan="2"><a id="af0c8e1665a381bfbb38307d296887e62"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af0c8e1665a381bfbb38307d296887e62"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_orderable_v</b> {<a class="el" href="structsequoia_1_1is__orderable.html">is_orderable</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:af0c8e1665a381bfbb38307d296887e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2f14963147fc2ebd35c47e778d7d5f"><td class="memTemplParams" colspan="2"><a id="a0c2f14963147fc2ebd35c47e778d7d5f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0c2f14963147fc2ebd35c47e778d7d5f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_equal_to_comparable_v</b> {<a class="el" href="structsequoia_1_1is__equal__to__comparable.html">is_equal_to_comparable</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:a0c2f14963147fc2ebd35c47e778d7d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb68fe73ee26115d9769661a3232fb6"><td class="memTemplParams" colspan="2"><a id="a5fb68fe73ee26115d9769661a3232fb6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5fb68fe73ee26115d9769661a3232fb6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_not_equal_to_comparable_v</b> {<a class="el" href="structsequoia_1_1is__not__equal__to__comparable.html">is_not_equal_to_comparable</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:a5fb68fe73ee26115d9769661a3232fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e39e504f3dc43235cc43c0d61c280f"><td class="memTemplParams" colspan="2"><a id="ae6e39e504f3dc43235cc43c0d61c280f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae6e39e504f3dc43235cc43c0d61c280f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_container_v</b> {<a class="el" href="structsequoia_1_1is__container.html">is_container</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:ae6e39e504f3dc43235cc43c0d61c280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877bcc9499bc67fa6cc09a115b1251ed"><td class="memTemplParams" colspan="2"><a id="a877bcc9499bc67fa6cc09a115b1251ed"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a877bcc9499bc67fa6cc09a115b1251ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_allocator_v</b> {<a class="el" href="structsequoia_1_1is__allocator.html">is_allocator</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:a877bcc9499bc67fa6cc09a115b1251ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0be0809e787b9f14722253e2d466354"><td class="memTemplParams" colspan="2"><a id="af0be0809e787b9f14722253e2d466354"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af0be0809e787b9f14722253e2d466354"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_serializable_v</b> {<a class="el" href="structsequoia_1_1is__serializable.html">is_serializable</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:af0be0809e787b9f14722253e2d466354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaabe0da8be36d787c7d7eb97e3bf73"><td class="memTemplParams" colspan="2"><a id="a5eaabe0da8be36d787c7d7eb97e3bf73"></a>
template&lt;template&lt; class... &gt; class T, class... Args&gt; </td></tr>
<tr class="memitem:a5eaabe0da8be36d787c7d7eb97e3bf73"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>class_template_is_instantiable_v</b> {<a class="el" href="structsequoia_1_1class__template__is__instantiable.html">class_template_is_instantiable</a>&lt;std::void_t&lt;&gt;, T, Args...&gt;::value}</td></tr>
<tr class="separator:a5eaabe0da8be36d787c7d7eb97e3bf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242464c76ac2b1d2968de022990ae288"><td class="memTemplParams" colspan="2"><a id="a242464c76ac2b1d2968de022990ae288"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a242464c76ac2b1d2968de022990ae288"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_regular_semantics_v</b> {<a class="el" href="structsequoia_1_1has__regular__semantics.html">has_regular_semantics</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:a242464c76ac2b1d2968de022990ae288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171faa3815f478b8d56239beb4e17112"><td class="memTemplParams" colspan="2"><a id="a171faa3815f478b8d56239beb4e17112"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a171faa3815f478b8d56239beb4e17112"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_move_only_semantics_v</b> {<a class="el" href="structsequoia_1_1has__move__only__semantics.html">has_move_only_semantics</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:a171faa3815f478b8d56239beb4e17112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992e315887bb4d372c93bef760db3bb8"><td class="memTemplParams" colspan="2"><a id="a992e315887bb4d372c93bef760db3bb8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a992e315887bb4d372c93bef760db3bb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_default_constructor_v</b> {<a class="el" href="structsequoia_1_1has__default__constructor.html">has_default_constructor</a>&lt;T&gt;::value}</td></tr>
<tr class="separator:a992e315887bb4d372c93bef760db3bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7116cfb2d39c72b37dadc705ff3e4d5d"><td class="memTemplParams" colspan="2"><a id="a7116cfb2d39c72b37dadc705ff3e4d5d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7116cfb2d39c72b37dadc705ff3e4d5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_allocator_type_v</b> = <a class="el" href="structsequoia_1_1has__allocator__type.html">has_allocator_type</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a7116cfb2d39c72b37dadc705ff3e4d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Useful specializations for the class template detailed_equality_checker. </p>
<p>Implementation details for semantics checks within the unit testing framework.</p>
<p>Extension for testing classes exhibiting regular semantics.</p>
<p>Implementation details for checking regular semantics within the unit testing framework.</p>
<p>Functions for checking regular semantics.</p>
<p>Extension for testing classes exhibiting move-only semantics.</p>
<p>Functions for checking semantics of types lacking copy semantics but which are otherwise regular.</p>
<p>Extension of unit testing framework for inexact comparisons.</p>
<p>Useful specializations for the class template equivalence_checker.</p>
<p>The specializations in this header are for various types defined in std. Internally, check_equality is used meaning that there will be automatic, recursive dispatch to other specializations of detailed_equality_checker, if appropriate. For example, consider two instances of std::pair&lt;my_type1, mytype2&gt;, x and y. The utilities in this header means the call</p>
<p>check_equality("descripion", logger, x, y);</p>
<p>will automatically call</p>
<p>check_equality("bigger desciption", logger, x.first, y,first)</p>
<p>and similarly for the second element. In turn, this nested check_equality will use a specialization of the detailed_equality_checker of my_type1, should it exist. As usual, if the specialization for T does not exist, but T may be interpretted as a container holding a type U, then everything will simply work, provided either that there exists a specialization of the detailed_equality_checker for U or U is serializable.</p>
<p>This header provides utilities for performing a comparison between two instances of a type utilising a generic function object. A particular use-case is comparison within a tolerance, for which a concrete function object is supplied.</p>
<p>The pattern is to provide a new overload for dispatch_check. Internally, if no compare object is identified for the given type, an attempt it made to interpret the type as a range. Thus if, for example, a fuzzy comparison is defined for a type, T, then no additional work is required to do a fuzzy comparison of the elements of a container of T. All that is required to do this is to feed the fuzzy_compare object to the existing check_range overload set and everything works smoothly.</p>
<p>Within this library, a type is defined to have move-only semantics if possesses the following:</p>
<p>move constructor move assignment swap operator== operator!=</p>
<p>but lacks</p>
<p>copy constructor copy assignment</p>
<p>Note that a default constructor is not a strict requirement.</p>
<p>This file adds one function to the check_semantics overload set, inside which consistency of the first list of operators above will be checked. There is an important difference compared to the corresponding overloads for regular semantics. Whereas the latter takes just two instance of T, x and y, in the move-only case 4 are taken. This is because, by definition, we cannot copy x and y and so, to be able to compare to the original values (essential for the mechanics of testing), immutable clones must be supplied.</p>
<p>This class is designed to be plugged into the checker class template, in order to extend its functionality. See <a class="el" href="_move_only_checkers_8hpp_source.html">MoveOnlyCheckers.hpp</a> for further information.</p>
<p>Types exhibiting regular semantics are pleasant to reason about. Within this library, a type is regular if it possesses the following:</p>
<p>copy constructor move constructor copy assignment move assignment swap operator== operator!=</p>
<p>Note that a default constructor is not a strict requirement. Types additionally possessing the remaining comparison operators will be referred to as having ordered semantics.</p>
<p>This file adds two functions to the check_semantics overload set; both functions are appropriate for testing the behaviour of types with regular semantics. Inside the functions, consistency of the operators listed above will be checked. One of the overloads also accepts a mutator. This will modify a copy of y, checking both that the copy is indeed changed and also that y is left alone. The reason for this is to check that classes which e.g. wrap a pointer have faithful copy semantics. For example, suppose that the copy constructor of vector were incorrectly implemented with the pointer, rather than what it points to, being copied. The mutation check would catch this. There is a similar check for copy assignment.</p>
<p>This class is designed to be plugged into the checker class template, in order to extend its functionality. See <a class="el" href="_regular_checkers_8hpp_source.html">RegularCheckers.hpp</a> for further information. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
