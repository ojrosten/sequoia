<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sequoia: The Testing Framework</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sequoia
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Testing Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <code>sequoia</code> testing framework is designed for <a class="el" href="../../dc/d92/testframeworkpage.html#sec_scale">scale</a> and is <a class="el" href="../../dc/d92/testframeworkpage.html#sec_automated">highly automated</a>, <a class="el" href="../../dc/d92/testframeworkpage.html#sec_robustness">robust</a>, <a class="el" href="../../dc/d92/testframeworkpage.html#sec_extensible">extensible</a>, <a class="el" href="../../dc/d92/testframeworkpage.html#sec_semantics">semantics-aware</a>, <a class="el" href="../../dc/d92/testframeworkpage.html#sec_allocators">allocator-aware</a>, <a class="el" href="../../dc/d92/testframeworkpage.html#sec_generics">generics-friendly</a> and <a class="el" href="../../dc/d92/testframeworkpage.html#sec_expressive">expressive</a>.</p>
<h1><a class="anchor" id="sec_scale"></a>
Scalabilty</h1>
<p>To operate effectively at scale, <code>sequoia</code> incorporates the following features:</p><ul>
<li>No waste: if a principled structure is adhered to, then running with the <code>prune</code> option will ensure that only those tests dependent on changes since the last run will be executed. Changes may be either to source files or materials exploited by the test. In particular:<ol type="1">
<li>cpp files should supply definitions only for the header of the same name;</li>
<li>Given a test file <code>Tests/Foo/Bar.cpp</code>, any testing materials should be stored in <code>TestMaterials\Foo\Bar</code>.</li>
</ol>
</li>
<li>Concurrency: by default, tests run concurrently. Tests are grouped into families and, by default, concurrency will be at the family level if there are more than three families; otherwise, concurrency is at the level of individual tests. However, this may be overridden using <code>--async-depth</code>.</li>
<li>Instability detection: <code>locate-instabilities</code> is called with an integer, specifying the number of times tests should be run. Instabilities are pinned down to the line of test code where they first manifest. By default, everything is run within the same program, allowing detection of changes to static data. However, it's conceivable that these changes are desired. To allow false positives, use the <code>--sandbox</code> flag to ensure that each run is done in an independent process.</li>
</ul>
<h1><a class="anchor" id="sec_automated"></a>
Automation</h1>
<p>The processes of initializating a new project, and creating new tests are highly automated. Both are integrated with CMake. For example, running with the command line arguments</p>
<pre>
    init "Jo Bloggs" "Some/Absolute/Path" "\t"
</pre><p>will do the following:</p><ol type="1">
<li>Create a new project in the specified location, with tabs preferred to spaces, and with the copyright of any new material created though mechanisms described below belonging to Jo Bloggs.</li>
<li>Invoke <code>CMake</code> to build the new project.</li>
<li>Initialize a new <code>git</code> repository and add the newly created project files.</li>
</ol>
<p>Additionally, on Windows:</p><ol type="1">
<li>Visual Studio will be launched, with the appropriate start-up project set.</li>
<li>The new project's (empty) test suite will be run.</li>
</ol>
<p>Once a new project has been created, it is natural to add code and tests. This can all be done automatically by utilizing the <code>create</code> mode which will add the appropriate files, amend the <code>CMakeLists.txt</code> files and run CMake.</p>
<h1><a class="anchor" id="sec_robustness"></a>
Robustness</h1>
<p>The testing framework is sophisticated and sophistication brings danger, since it raises the chances that the framework itself has bugs. If this is the case, then the framework would give clients a false sense of security about the code they have written, which could be disastrous. To mitigate this risk, the testing framework has been designed to run self-diagnostics. This has been employed to give a high degree of confidence that the existing framework is correct. Used idiomatically, it should confer similar confidence in any extensions.</p>
<p>One of the defining features of the testing framework is that it is designed to expose false-positives. As such, each test operates in a particular <a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#test_mode_enum">test_mode</a>, chosen at compile time: standard, false_positive and false_negative.</p>
<p>In standard mode, the test framework operates as one might expect. A typical check looks as follows:</p>
<pre>
check_equality("Description of test", x, 5);
</pre><p>If <code>x==5</code> the check passes, whereas if <code>x!=5</code> a failure is reported. However, suppose that check_equality has a bug. For example, it might never report failure. To counter this, tests can be created to be run in false-positive mode. In this case, the above example will pass when <code>x!=5</code> and fail when <code>x==5</code>. The purpose of this is to pick up bugs in the testing framework itself.</p>
<p>In standard mode, when a test fails, details of the failure will be given directly to the client. In the above example, for the case where <code>x==4</code>, something like this will be seen:</p>
<pre>
Obtained : 4
Predicted: 5
</pre><p>In false-positive mode, this output is not made directly visible to the user, since the false-positive test has succeeded. Instead, it is dumped to a file. This means that clients can check whether the underlying failure which the false-positive check has detected is as expected. It is good practice to place this file under version control. This provides sensitivity both to changes in the false-positive test and also changes to the way in which the testing framework generates output.</p>
<p>Clients may extend the testing framework to conveniently test their types, for example by specializing the <a class="el" href="../../da/dc4/structsequoia_1_1testing_1_1value__checker.html#value_checker_primary">value_checker</a> (see <a class="el" href="../../dc/d92/testframeworkpage.html#sec_extensible">Extensibility</a>). This is a perfect opportunity to write some false-positive tests to give confidence that the newly-added code is not spuriously reporting success.</p>
<p>Finally, there are false-negative tests. They are essentially the same as standard mode tests; however, they are treated separately since statements like</p>
<pre>
check_equality("Description of test", 5, 5);
</pre><p>are morally tests of the testing framework itself, rather than tests of client code. As with false-positive tests, output is dumped to an auxiliary file, primarily as a means of detecting (via version control) changes to the way the testing framework generates output.</p>
<h1><a class="anchor" id="sec_extensible"></a>
Extensibility</h1>
<p>There are several ways in which the testing framework may be extended. Suppose that a client has created a new type, <code>my_type</code>. One way or another, it is almost inevitable that calls will be made to <code>check_equality</code>. If the type is sufficiently simple, and defines <code>operator==</code>, it suffices for clients to specialize the class template <a class="el" href="../../d6/d39/structsequoia_1_1testing_1_1serializer.html#serializer_primary">serializer</a>. This defines how to serialize instances of the class and so we may again end up with a failure report along the lines of the above. However, if the class is more complex, there is a superior alternative.</p>
<p><code>sequoia</code> defines a class template, <a class="el" href="../../da/dc4/structsequoia_1_1testing_1_1value__checker.html#value_checker_primary">value_checker</a>. The purpose of this is to use the <code>const</code> accessors of two instances of a class to probe their purported equality. Suppose that a client has created a new container and consider comparing two instances. <code>operator==</code> may return <code>false</code> or <code>true</code>. In the first case, we want to get to the bottom of this, in a more appropriate manner than simply serializing the class (which may produce excessive output). For a container, it would make sense compare the size and then to use iterators to compare the elements and find any that differ. However, it is worth doing this even if <code>operator==</code> returns <code>true</code>; after all, the aim is to test with high fidelity and it may be that <code>operator==</code> has a bug; or perhaps it is fine but there's a bug in the const accessors. Either way, a well designed specialization of the <a class="el" href="../../da/dc4/structsequoia_1_1testing_1_1value__checker.html#value_checker_primary">value_checker</a> will catch these potential inconsistencies.</p>
<p>However, there is a gap here. Consider the the first time a type is instantiated in a test, say</p>
<pre>
my_type x{5};
</pre><p>It is desirable to check that <code>x</code> is correctly initialized, but circular to write something like</p>
<pre>
check_equality("x correctly initialized", x, my_type{5});
</pre><p>Therefore, in addition to the <a class="el" href="../../da/dc4/structsequoia_1_1testing_1_1value__checker.html#value_checker_primary">value_checker</a>, the framework defines two class templates, <a class="el" href="../../d2/d52/structsequoia_1_1testing_1_1equivalence__checker.html#equivalence_checker_primary">equivalence_checker</a> and <a class="el" href="../../df/dff/structsequoia_1_1testing_1_1weak__equivalence__checker.html#weak_equivalence_checker_primary">weak_equivalence_checker</a>. Suppose that, in this example, <code>my_type</code> simply wraps an <code>int</code>. Here it may make sense to define the specialization <code>equivalence_checker&lt;my_type&gt;</code>; internally, this will define a static function, <code>check</code>, which defines a comparison between <code>my_type</code> and <code>int</code>. The line of code above may then be replaced by</p>
<pre>
check_equivalence("x correctly initialized", x, 5);
</pre><p>Once consistency of initialization has been checked, thereafter it makes sense to revert to <code>check_equality</code>.</p>
<p>What of the <a class="el" href="../../df/dff/structsequoia_1_1testing_1_1weak__equivalence__checker.html#weak_equivalence_checker_primary">weak_equivalence_checker</a>? This is for cases where there is a signifcant mismatch between the information content of the type to be checked and the type it is being compared with.</p>
<p>There is also an entirely different way in which the testing framework may be extended. The <a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#checker_primary">checker</a> class template provides basic functionality such as <code>check_equality</code> and <code>check_exception_thrown</code>. However, the class template accepts a variadic number of extenders, which enhance its functionality. Examples provided with <code>sequoia</code> are various semantics extenders (see below), a <a class="el" href="../../d6/d92/classsequoia_1_1testing_1_1performance__extender.html#performance_extender_primary">performance_extender</a>, and a fuzzy_extender for doing fuzzy comparisons. These may be readily mixed and matched with appropriate using declarations, some of which are supplied with the library. If a client of the code wishes to provide a new extension, simply follow the existing pattern using e.g. FuzzyTestCore.hpp as an example.</p>
<h1><a class="anchor" id="sec_semantics"></a>
Semantics-Awareness</h1>
<p>By utilizing <code>sequoia</code>'s testing framework, clients are strongly encourged to think carefully about the semantics of their classes upfront, rather than as an after-thought. For the purposes of this library, a type exhibiting regular semantics is understood to exhibit copy/move constructors, copy/move assigment, <code>operator==</code>, <code>operator!=</code> and swap. Note that there is no strict requirement for a default constructor. If a class provides this functionality, then the <a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#regular_test_alias">regular_test</a> alias template may be utilized, which makes use of the <a class="el" href="../../d4/d5d/classsequoia_1_1testing_1_1regular__extender.html#regular_extender_primary">regular_extender</a> class template. The latter provides an overload of <code>check_semantics</code>: given two instantiations of a class it checks consistency of the above list of special member functions / functions. Alternatively, for move-only types (defined as regular types but for which the copy operations are removed), the <a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#move_only_test_alias">move_only_test</a> may be exploited. Either way, this removes much of the burden of devising ways to carefully check consistency of these operations by reliably bundling everything into a call to check_semantics.</p>
<h1><a class="anchor" id="sec_allocators"></a>
Allocator-Awareness</h1>
<p>The C++17 allocator framework is powerful but complex. Much of this complexity derives from the intersection of the logical abstraction containers seek to represent with the realities of creating efficient code. Consider <code>std::vector</code>. This models dynamic, contiguous storage: the logical content of this container is its elements. Indeed, <code>operator==</code> checks that two vectors are of the same size and that its elements are equal, but no more than this. However, vectors additionally comprise allocators which are not part of the logical abstraction. In principle, the allocator maybe stateful and this raises interesting questions. Should <code>operator==</code> take account of this state? The design of <code>std::vector</code> gives a definitive answer: No. But what should be done when doing assignment? Should the state of the allocator propagate or not. Should the choice be consistent between copy assignment and move assignment? What about swapping? There are no definitive answers to these questions and so this is left in the hands of the client. Indeed, <code>std::allocator_traits</code> exposes various type definitions, reflecting this freedom.</p>
<p>With flexibility of the C++ allocation model comes commensurate difficulty when it comes to testing. To help with this, the <code>sequoia</code> testing framework has been built with allocators firmly in mind. An allocator-aware class with regular semantics may be rigorously tested by using a <a class="el" href="../../da/dcc/classsequoia_1_1testing_1_1regular__allocation__extender.html#regular_allocation_extender_primary">regular_allocation_extender</a>; for the move-only case <a class="el" href="../../d7/d8c/classsequoia_1_1testing_1_1move__only__allocation__extender.html#move_only_allocation_extender_primary">move_only_allocation_extender</a> is available. These checkers provides an overload of the check_semantics method which accepts allocation predictions. In the regular case, the latter correspond to copying, assigning (with and without propagation) and mutation, together with para-copy/move. Here and throught the documentation para copy/move refer to the copy-like and move-like constructors which additionally accept an allocator. The design accomodates scoped allocators and multiple allocators (be each of them normal or scoped). <a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#regular_allocation_test_alias">Regular allocation tests</a> come with a facility for automatically generating all 8 combinations of allocation propagation from a single call to <code>check_semantics</code>. <a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#move_only_allocation_test_alias">Move-only allocation tests</a> do likewise for the 4 combinations relevant to move-only types.</p>
<p>An additional subtlety arises from attempting to ensure independence on library implementations and build settings. This is sharpened by the fact that certain operations on the standard containers perform additional allocations in an MSVC debug build, compared to a release build. However, the framework is flexible enough to deal with this. Indeed, if the semantics are such that the container under inspection behaves like a container of values, then the framework automatically shifts the user-supplied allocation predictions to compensate. If, instead, it behaves like a container of pointers, then a line of code registering this fact is sufficient. If the behaviour does not fit into either of these categories, then the framework is flexible enough for clients to specify their own solutions.</p>
<p>The allocation testing framework has been rigorously tested with a combination of false-positive and false-negative checks and has very high fidelity. For example, if <code>check_semantics</code> is fed instances of an allocating type for which <code>operator==</code> has accidentally been written such that one (or both) of its arguments are captured by value, rather than by reference, the framework will detect this.</p>
<h1><a class="anchor" id="sec_generics"></a>
Generics-Friendliness</h1>
<p>When writing generic code, it is natural to want to test it with a variety of appropriate types. This leads to the idea of templated unit tests; within <code>sequoia</code> this is most naturally achieved by leaving the test classes plain (rather than templated) but templating various methods inside. However, a challenge with doing this is interpreting failures. The line at which the failure occurs is no longer enough to uniquely disambiguate, since this line may correspond to several different template instantiations.</p>
<p>Consequently, <code>sequoia</code> reports failures with plenty of type information. For example, the following output is typical of what to expect when checking the equality of two instances of <code>std::pair&lt;int,double&gt;</code>:</p>
<pre>
../Tests/TestFramework/UnitTestDiagnostics.cpp, Line 51
[std::pair&lt;int, double&gt;]
operator== returned false</pre><pre>Second element of pair is incorrect
[double]
operator== returned false
Obtained : 7.8
Predicted: -7.8
</pre><p>For each sub-check performed as part of the top-level check, type information is reported. This is generated by the class template <a class="el" href="../../d3/d78/structsequoia_1_1testing_1_1type__demangler.html#type_demangler_primary">type_demangler</a>. Clients are welcome to specialize this to provide more readable demangling.</p>
<h1><a class="anchor" id="sec_expressive"></a>
Expressiveness</h1>
<p>The focus of the testing framework's API is on providing useful primitives, such as <code>check_equality</code> and <code>check_semantics</code>, rather than providing classes with names like 'Then' and 'That'. However, in addition to encouraging clients to think seriously about providing each check with a descriptive string (which, being the first argument of each check method, is firmly encouraged), there is the facility to provide customized advice in the event of particular failures. For example, within the allocation testing framework, it is possible for a negative number of allocations to be reported. This is rather counter-intuitive and, when encountered for the first time, may raise doubts as to the correctness of the framework. This is hopefully ameliorated by levaraging the advice functionality internally, giving typical output:</p>
<pre>
Obtained : -1
Predicted: 1
Advice   : A negative allocation count generally indicates an allocator propagting when it shouldn't or not propagating when it should.
</pre><p>Clients may provided customized advice by calling many of the check methods with an extra function object bound to an instance of the <a class="el" href="../../d6/d71/classsequoia_1_1testing_1_1tutor.html#tutor_primary">tutor</a> class template. If <code>operator()</code> is overloaded in such a way that it takes two instances of a type and returns a string, then reflection is utilized to apply this function object whenever the appropriate overload may be invoked. For example, consider the case where a function object is supplied to provide advice for ints, under certain conditions. Suppose this function object is fed to a check performed on a <code>std::vector&lt;int&gt;</code>. In this case, the function object will be propagated internally until it reaches the point where it can be invoked on the <code>int</code>s at the end of the chain. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
