<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sequoia: /Users/Claire/Dropbox/Sequoia/Source/sequoia/TestFramework/FreeCheckers.hpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sequoia
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_74389ed8173ad57b461b9d623a1f3867.html">Source</a></li><li class="navelem"><a class="el" href="../../dir_2cc7e707cf7d8b577b4d17c7cb9b6739.html">sequoia</a></li><li class="navelem"><a class="el" href="../../dir_b8a7430685850b8d4f731afcd36d4c52.html">TestFramework</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">FreeCheckers.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Free functions for performing checks, together with the 'checker' class template which wraps them.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="../../d0/dae/CoreInfrastructure_8hpp_source.html">sequoia/TestFramework/CoreInfrastructure.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d1/d8b/BinaryRelationships_8hpp_source.html">sequoia/TestFramework/BinaryRelationships.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../da/d27/Advice_8hpp_source.html">sequoia/TestFramework/Advice.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d5/d05/TestLogger_8hpp_source.html">sequoia/TestFramework/TestLogger.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../db/dc4/Source_2sequoia_2Core_2Meta_2Utilities_8hpp_source.html">sequoia/Core/Meta/Utilities.hpp</a>&quot;</code><br />
</div>
<p><a href="../../d2/d0d/FreeCheckers_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3a/structsequoia_1_1testing_1_1value__based__customization.html">sequoia::testing::value_based_customization&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/structsequoia_1_1testing_1_1value__based__customization_3_01void_01_4.html">sequoia::testing::value_based_customization&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d34/structsequoia_1_1testing_1_1equivalent__type__processor.html">sequoia::testing::equivalent_type_processor&lt; Ts &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0d/structsequoia_1_1testing_1_1equivalent__type__processor_3_01Ts_8_8_8_01_4.html">sequoia::testing::equivalent_type_processor&lt; Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d02/structsequoia_1_1testing_1_1exception__message__extractor.html">sequoia::testing::exception_message_extractor&lt; class &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/structsequoia_1_1testing_1_1exception__message__extractor_3_01E_01_4.html">sequoia::testing::exception_message_extractor&lt; E &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/structsequoia_1_1testing_1_1equivalence__checker__delegator.html">sequoia::testing::equivalence_checker_delegator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd3/structsequoia_1_1testing_1_1default__exception__message__postprocessor.html">sequoia::testing::default_exception_message_postprocessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de5/classsequoia_1_1testing_1_1checker.html">sequoia::testing::checker&lt; Mode, Extenders &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:dd/da8/namespacesequoia_1_1testing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html">sequoia::testing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02b3eade26bcab90b32fd3ef49dbfeb3"><td class="memItemLeft" align="right" valign="top"><a id="a02b3eade26bcab90b32fd3ef49dbfeb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sequoia::testing::impl::fall_back</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, Tag, const value_based_customization&lt; Customization &gt; &amp;customization, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="separator:a02b3eade26bcab90b32fd3ef49dbfeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa698dfaac9328a6b12c2b6f9cc275f5"><td class="memTemplParams" colspan="2"><a id="afa698dfaac9328a6b12c2b6f9cc275f5"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:afa698dfaac9328a6b12c2b6f9cc275f5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::requires</b> (!std::derived_from&lt; E, std::exception &gt;) &amp;&amp;serializable&lt; E &gt; struct exception_message_extractor&lt; E &gt;</td></tr>
<tr class="separator:afa698dfaac9328a6b12c2b6f9cc275f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8278d9ecb6065fa491616aa51d27efb"><td class="memTemplParams" colspan="2">template&lt;class EquivChecker , test_mode Mode, class Customization , class T , class S , class... U&gt; </td></tr>
<tr class="memitem:ad8278d9ecb6065fa491616aa51d27efb"><td class="memTemplItemLeft" align="right" valign="top">requires implements_general_equivalence_check&lt; EquivChecker, Mode, Customization, T, S, U... &gt; bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#ad8278d9ecb6065fa491616aa51d27efb">sequoia::testing::general_equivalence_check</a> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, [[maybe_unused]] const value_based_customization&lt; Customization &gt; &amp;customization, const T &amp;value, const S &amp;s, const U &amp;... u)</td></tr>
<tr class="memdesc:ad8278d9ecb6065fa491616aa51d27efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic function that generates a check from any class providing a static check method.  <a href="../../dd/da8/namespacesequoia_1_1testing.html#ad8278d9ecb6065fa491616aa51d27efb">More...</a><br /></td></tr>
<tr class="separator:ad8278d9ecb6065fa491616aa51d27efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39d2c00fb7c15c1249ea5454e6a0ea1"><td class="memTemplParams" colspan="2"><a id="ae39d2c00fb7c15c1249ea5454e6a0ea1"></a>
template&lt;test_mode Mode, class Compare , class T , class Advisor &gt; </td></tr>
<tr class="memitem:ae39d2c00fb7c15c1249ea5454e6a0ea1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::binary_comparison</b> (sentinel&lt; Mode &gt; &amp;sentry, Compare compare, const T &amp;obtained, const T &amp;prediction, tutor&lt; Advisor &gt; advisor)</td></tr>
<tr class="separator:ae39d2c00fb7c15c1249ea5454e6a0ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4e7c7394e54bdf2833d7e1165f11ca10"><td class="memTemplParams" colspan="2">template&lt;class Checker , test_mode Mode, class... Args&gt; </td></tr>
<tr class="memitem:a4e7c7394e54bdf2833d7e1165f11ca10"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::checker_for</b></td></tr>
<tr class="separator:a4e7c7394e54bdf2833d7e1165f11ca10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b7c71908b9f0a75bb171aef6ac35b1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a50b7c71908b9f0a75bb171aef6ac35b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::is_value_customizer</b></td></tr>
<tr class="separator:a50b7c71908b9f0a75bb171aef6ac35b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830946075c73f91cead550bbc0895e0b"><td class="memTemplParams" colspan="2">template&lt;class Fn , class... Args&gt; </td></tr>
<tr class="memitem:a830946075c73f91cead550bbc0895e0b"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::impl::invocable_without_last_arg</b></td></tr>
<tr class="separator:a830946075c73f91cead550bbc0895e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4516f78de4a5ea373f8a31bcc73f45a0"><td class="memTemplParams" colspan="2"><a id="a4516f78de4a5ea373f8a31bcc73f45a0"></a>
template&lt;test_mode Mode, class Customization , class Tag , class T , class S , class... U&gt; </td></tr>
<tr class="memitem:a4516f78de4a5ea373f8a31bcc73f45a0"><td class="memTemplItemLeft" align="right" valign="top">requires&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::impl::requires</b> { Tag::template checker&lt;T&gt;</td></tr>
<tr class="separator:a4516f78de4a5ea373f8a31bcc73f45a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795670673da497f3ce62fe55f8d05128"><td class="memTemplParams" colspan="2">template&lt;class EquivChecker , test_mode Mode, class Customization , class T , class S , class... U&gt; </td></tr>
<tr class="memitem:a795670673da497f3ce62fe55f8d05128"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::implements_general_equivalence_check</b></td></tr>
<tr class="separator:a795670673da497f3ce62fe55f8d05128"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
dispatch_check basic overload set</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5d910c0f2c58303f585b6b2acacdebb2"></a>The next batch of functions form an overload set, dedicated to appropiately dispatching requests to check equality, binary relationships, equivalence and weak equivalence.</p>
<p>In each case, the final argument may be utilized to supply custom advice, targeted at particular failures which may benefit from explanation. To active this, clients must supply a function object, with operator() overloaded to take two instances of a type and returning a string. Internally, reflection is used to invoke this function only when the matching type is obtained. Therefore, advice for type T can be supplied to a check of e.g. std::vector&lt;T&gt;, and the advice will find its way to the correct invocation site.</p>
<p><a class="anchor" id="dispatch_check_free_overloads"></a></p>
</td></tr>
<tr class="memitem:ac460355a425fb4db86211989c86e9af1"><td class="memTemplParams" colspan="2">template&lt;class T , test_mode Mode&gt; </td></tr>
<tr class="memitem:ac460355a425fb4db86211989c86e9af1"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#ac460355a425fb4db86211989c86e9af1">sequoia::testing::extender</a></td></tr>
<tr class="memdesc:ac460355a425fb4db86211989c86e9af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes elementary check methods, with the option to plug in arbitrary Extenders to compose functionality.  <a href="../../dd/da8/namespacesequoia_1_1testing.html#ac460355a425fb4db86211989c86e9af1">More...</a><br /></td></tr>
<tr class="separator:ac460355a425fb4db86211989c86e9af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb337f52732959b7ac769497c5a6bc33"><td class="memTemplParams" colspan="2">template&lt;test_mode Mode, class Customization , class T , class Advisor  = null_advisor&gt; </td></tr>
<tr class="memitem:adb337f52732959b7ac769497c5a6bc33"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#adb337f52732959b7ac769497c5a6bc33">sequoia::testing::requires</a> (has_value_checker_v&lt; T &gt;||sequoia::range&lt; T &gt;||std::equality_comparable&lt; T &gt;) bool dispatch_check(std</td></tr>
<tr class="memdesc:adb337f52732959b7ac769497c5a6bc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The workhorse of equality checking, which takes responsibility for reflecting upon types and then dispatching, appropriately.  <a href="../../dd/da8/namespacesequoia_1_1testing.html#adb337f52732959b7ac769497c5a6bc33">More...</a><br /></td></tr>
<tr class="separator:adb337f52732959b7ac769497c5a6bc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3395a201397bca20a895c46203f76c"><td class="memItemLeft" align="right" valign="top"><a id="a0c3395a201397bca20a895c46203f76c"></a>
if&#160;</td><td class="memItemRight" valign="bottom"><b>sequoia::testing::constexpr</b> (std::equality_comparable&lt; T &gt;)</td></tr>
<tr class="separator:a0c3395a201397bca20a895c46203f76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5624cc7731851697d563e0caa54e9e89"><td class="memItemLeft" align="right" valign="top"><a id="a5624cc7731851697d563e0caa54e9e89"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>sequoia::testing::if</b> (has_value_checker_v&lt; T &gt;)</td></tr>
<tr class="separator:a5624cc7731851697d563e0caa54e9e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8b4df70c6fe74460f5fbf6a13e2999"><td class="memItemLeft" align="right" valign="top"><a id="a6d8b4df70c6fe74460f5fbf6a13e2999"></a>
else constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>sequoia::testing::if</b> (sequoia::range&lt; T &gt;)</td></tr>
<tr class="separator:a6d8b4df70c6fe74460f5fbf6a13e2999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853036ad8ba3ea9c64f2e39e5e22b70c"><td class="memItemLeft" align="right" valign="top"><a id="a853036ad8ba3ea9c64f2e39e5e22b70c"></a>
return !sentry&#160;</td><td class="memItemRight" valign="bottom"><b>sequoia::testing::failure_detected</b> ()</td></tr>
<tr class="separator:a853036ad8ba3ea9c64f2e39e5e22b70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d81c642c83b1ef5c4c09a22c71dd9e2"><td class="memTemplParams" colspan="2">template&lt;test_mode Mode, class Customization , class Compare , class T , class Advisor &gt; </td></tr>
<tr class="memitem:a9d81c642c83b1ef5c4c09a22c71dd9e2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da8/namespacesequoia_1_1testing.html#a9d81c642c83b1ef5c4c09a22c71dd9e2">sequoia::testing::requires</a> (std::invocable&lt; Compare, T, T &gt;||sequoia::range&lt; T &gt;) bool dispatch_check(std</td></tr>
<tr class="memdesc:a9d81c642c83b1ef5c4c09a22c71dd9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The workhorse for performing a check with respect to a user-specified binary operator.  <a href="../../dd/da8/namespacesequoia_1_1testing.html#a9d81c642c83b1ef5c4c09a22c71dd9e2">More...</a><br /></td></tr>
<tr class="separator:a9d81c642c83b1ef5c4c09a22c71dd9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681d80800513dc1d90076a44e8e4267a"><td class="memItemLeft" align="right" valign="top"><a id="a681d80800513dc1d90076a44e8e4267a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sequoia::testing::dispatch_check</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, Tag, const value_based_customization&lt; Customization &gt; &amp;customization, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="separator:a681d80800513dc1d90076a44e8e4267a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade903333ea43b082a8fd2e43860cbcca"><td class="memTemplParams" colspan="2"><a id="ade903333ea43b082a8fd2e43860cbcca"></a>
template&lt;test_mode Mode, class ElementDispatchDiscriminator , class Customization , std::input_or_output_iterator Iter, std::sentinel_for&lt; Iter &gt; Sentinel, std::input_or_output_iterator PredictionIter, std::sentinel_for&lt; PredictionIter &gt; PredictionSentinel, class Advisor  = null_advisor&gt; </td></tr>
<tr class="memitem:ade903333ea43b082a8fd2e43860cbcca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_range</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, ElementDispatchDiscriminator discriminator, const value_based_customization&lt; Customization &gt; &amp;customization, Iter first, Sentinel last, PredictionIter predictionFirst, PredictionSentinel predictionLast, tutor&lt; Advisor &gt; advisor={})</td></tr>
<tr class="separator:ade903333ea43b082a8fd2e43860cbcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dc8803b7a0c1229343c6a49da20896"><td class="memTemplParams" colspan="2"><a id="a11dc8803b7a0c1229343c6a49da20896"></a>
template&lt;class E , test_mode Mode, class Fn , invocable_r&lt; std::string, std::string &gt; Postprocessor = default_exception_message_postprocessor&gt; </td></tr>
<tr class="memitem:a11dc8803b7a0c1229343c6a49da20896"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_exception_thrown</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, Fn &amp;&amp;function, Postprocessor postprocessor={})</td></tr>
<tr class="separator:a11dc8803b7a0c1229343c6a49da20896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc6e30ba1cf607d6b5f677efdc02908"><td class="memTemplParams" colspan="2"><a id="aebc6e30ba1cf607d6b5f677efdc02908"></a>
template&lt;test_mode Mode, class Compare , class T , class Advisor  = null_advisor&gt; </td></tr>
<tr class="memitem:aebc6e30ba1cf607d6b5f677efdc02908"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_relation</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, Compare &amp;&amp;compare, const T &amp;obtained, const T &amp;prediction, tutor&lt; Advisor &gt; advisor={})</td></tr>
<tr class="separator:aebc6e30ba1cf607d6b5f677efdc02908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea237638154d078fb0acc83542dbd4d"><td class="memTemplParams" colspan="2"><a id="a7ea237638154d078fb0acc83542dbd4d"></a>
template&lt;test_mode Mode, class T , class Advisor  = null_advisor&gt; </td></tr>
<tr class="memitem:a7ea237638154d078fb0acc83542dbd4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_equality</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, const T &amp;value, const T &amp;prediction, tutor&lt; Advisor &gt; advisor={})</td></tr>
<tr class="separator:a7ea237638154d078fb0acc83542dbd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee413d8eaa5b9f8f41551479ada9831b"><td class="memTemplParams" colspan="2"><a id="aee413d8eaa5b9f8f41551479ada9831b"></a>
template&lt;test_mode Mode, class T , class S , class... U&gt; </td></tr>
<tr class="memitem:aee413d8eaa5b9f8f41551479ada9831b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_equivalence</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="separator:aee413d8eaa5b9f8f41551479ada9831b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c953cf89254bcf652033e4db4f62ab9"><td class="memTemplParams" colspan="2"><a id="a9c953cf89254bcf652033e4db4f62ab9"></a>
template&lt;class Customization , test_mode Mode, class T , class S , class... U&gt; </td></tr>
<tr class="memitem:a9c953cf89254bcf652033e4db4f62ab9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_equivalence</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, const value_based_customization&lt; Customization &gt; &amp;customization, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="separator:a9c953cf89254bcf652033e4db4f62ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccdced94b1f4c361c16336b20598577"><td class="memTemplParams" colspan="2"><a id="afccdced94b1f4c361c16336b20598577"></a>
template&lt;test_mode Mode, class T , class S , class... U&gt; </td></tr>
<tr class="memitem:afccdced94b1f4c361c16336b20598577"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_weak_equivalence</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="separator:afccdced94b1f4c361c16336b20598577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee20c5429d0dbe82e837240cc87d82db"><td class="memTemplParams" colspan="2"><a id="aee20c5429d0dbe82e837240cc87d82db"></a>
template&lt;class Customization , test_mode Mode, class T , class S , class... U&gt; </td></tr>
<tr class="memitem:aee20c5429d0dbe82e837240cc87d82db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_weak_equivalence</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, const value_based_customization&lt; Customization &gt; &amp;customization, const T &amp;value, S &amp;&amp;s, U &amp;&amp;... u)</td></tr>
<tr class="separator:aee20c5429d0dbe82e837240cc87d82db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da5f6030787fd6a86f5160c58018a70"><td class="memTemplParams" colspan="2"><a id="a2da5f6030787fd6a86f5160c58018a70"></a>
template&lt;test_mode Mode, class Advisor  = null_advisor&gt; </td></tr>
<tr class="memitem:a2da5f6030787fd6a86f5160c58018a70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, const bool value, tutor&lt; Advisor &gt; advisor={})</td></tr>
<tr class="separator:a2da5f6030787fd6a86f5160c58018a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384994feeef325d5815e8946bd8daf5a"><td class="memTemplParams" colspan="2"><a id="a384994feeef325d5815e8946bd8daf5a"></a>
template&lt;test_mode Mode, std::input_or_output_iterator Iter, std::sentinel_for&lt; Iter &gt; Sentinel, std::input_or_output_iterator PredictionIter, std::sentinel_for&lt; PredictionIter &gt; PredictionSentinel, class Advisor  = null_advisor&gt; </td></tr>
<tr class="memitem:a384994feeef325d5815e8946bd8daf5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_range</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, Iter first, Sentinel last, PredictionIter predictionFirst, PredictionSentinel predictionLast, tutor&lt; Advisor &gt; advisor={})</td></tr>
<tr class="separator:a384994feeef325d5815e8946bd8daf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08560e33fdd3daab19e402443ce6e22d"><td class="memTemplParams" colspan="2"><a id="a08560e33fdd3daab19e402443ce6e22d"></a>
template&lt;test_mode Mode, std::input_or_output_iterator Iter, std::sentinel_for&lt; Iter &gt; Sentinel, std::input_or_output_iterator PredictionIter, std::sentinel_for&lt; PredictionIter &gt; PredictionSentinel, class Advisor  = null_advisor&gt; </td></tr>
<tr class="memitem:a08560e33fdd3daab19e402443ce6e22d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_range_equivalence</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, Iter first, Sentinel last, PredictionIter predictionFirst, PredictionSentinel predictionLast, tutor&lt; Advisor &gt; advisor={})</td></tr>
<tr class="separator:a08560e33fdd3daab19e402443ce6e22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b2ff089d2b73c08f5ac13797b4d8cb"><td class="memTemplParams" colspan="2"><a id="ab9b2ff089d2b73c08f5ac13797b4d8cb"></a>
template&lt;test_mode Mode, class Customization , std::input_or_output_iterator Iter, std::sentinel_for&lt; Iter &gt; Sentinel, std::input_or_output_iterator PredictionIter, std::sentinel_for&lt; PredictionIter &gt; PredictionSentinel, class Advisor  = null_advisor&gt; </td></tr>
<tr class="memitem:ab9b2ff089d2b73c08f5ac13797b4d8cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_range_equivalence</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, const value_based_customization&lt; Customization &gt; &amp;customization, Iter first, Sentinel last, PredictionIter predictionFirst, PredictionSentinel predictionLast, tutor&lt; Advisor &gt; advisor={})</td></tr>
<tr class="separator:ab9b2ff089d2b73c08f5ac13797b4d8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe648008843d91904ca923c962d743d"><td class="memTemplParams" colspan="2"><a id="a2fe648008843d91904ca923c962d743d"></a>
template&lt;test_mode Mode, std::input_or_output_iterator Iter, std::sentinel_for&lt; Iter &gt; Sentinel, std::input_or_output_iterator PredictionIter, std::sentinel_for&lt; PredictionIter &gt; PredictionSentinel&gt; </td></tr>
<tr class="memitem:a2fe648008843d91904ca923c962d743d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_range_weak_equivalence</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, Iter first, Sentinel last, PredictionIter predictionFirst, PredictionSentinel predictionLast)</td></tr>
<tr class="separator:a2fe648008843d91904ca923c962d743d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4bb619d63f8edb8127e06318d6616d"><td class="memTemplParams" colspan="2"><a id="aff4bb619d63f8edb8127e06318d6616d"></a>
template&lt;test_mode Mode, class Customization , std::input_or_output_iterator Iter, std::sentinel_for&lt; Iter &gt; Sentinel, std::input_or_output_iterator PredictionIter, std::sentinel_for&lt; PredictionIter &gt; PredictionSentinel&gt; </td></tr>
<tr class="memitem:aff4bb619d63f8edb8127e06318d6616d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequoia::testing::check_range_weak_equivalence</b> (std::string_view description, test_logger&lt; Mode &gt; &amp;logger, const value_based_customization&lt; Customization &gt; &amp;customization, Iter first, Sentinel last, PredictionIter predictionFirst, PredictionSentinel predictionLast)</td></tr>
<tr class="separator:aff4bb619d63f8edb8127e06318d6616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Free functions for performing checks, together with the 'checker' class template which wraps them. </p>
<p>Given a type, T, any reasonable testing framework must provide a mechanism for checking whether or not two instances of T are, in some sense, the same. If the type implements operator== then it is natural to utilize this. However, there is much more to the story. First of all, if this check fails then, in order to be useful, there must be some way of serializing the state of T. This may be done by specializing the class template string_maker for cases where operator&lt;&lt; is not appropriately overloaded.</p>
<p>However, there is an alternative which may be superior. Consider trying to implement vector. This class has various const accessors suggesting that, if operator== returns false, then the accessors can be used to probe the exact nature of the inequality. To this end, a class template <a class="el" href="../../da/dc4/structsequoia_1_1testing_1_1value__checker.html#value_checker_primary">value_checker</a> is defined. Specializations perform a detailed check of the equality of the state of two supposedly equal instance of a class. Note that there is no need for the value_checker to include checks of operator== or operator!=, since these will be done, regardless. Indeed, the value_checker will be triggered independently of whether operator== fails since either the latter or the accessors may have bugs, and introducing unnecessary dependencies would reduce the fidelity of the testing framework.</p>
<p>If a value_checker is supplied, then compile-time logic will ignore any attempt to serialize objects of type T. Typically, clients may expect a notification that operator== has returned false. There will then be a series of subsequent checks which will reveal the precise nature of the failure. For example, for vectors, one will be told whether the sizes differ and, if not, the element which is causing the difference between the two supposedly equal instances. If the vector holds a user-defined type then, so long as this has its own value_checker, the process will continue until a type is reached without a value_checker; typically this will be a sufficiently simple type that serialization is the appropriate solution (as is the case for may built-in types).</p>
<p>Suppose a client wishes to compare instance of some_container&lt;T&gt;. If some_container has a specialization of <a class="el" href="../../da/dc4/structsequoia_1_1testing_1_1value__checker.html#value_checker_primary">value_checker</a> then this will be used; if it does not then reflection is used to determine if some_container overloads begin and end. If so, then it is treated as a range and all that is required is to implement a value_checker for T (unless serialization is prefered). If some_container is user-defined, it is wisest to provide an overload of the <a class="el" href="../../da/dc4/structsequoia_1_1testing_1_1value__checker.html#value_checker_primary">value_checker</a>. However, if the container is part of std, it is probably safe to assume it works correctly and so instead effort can be directed focused on T.</p>
<p>With this in mind, imagine creating a container. One of the first things one may wish to do is to check that it is correctly initialized. It would be a mistake to use the <a class="el" href="../../da/dc4/structsequoia_1_1testing_1_1value__checker.html#value_checker_primary">value_checker</a> for this since, to do so, a second, identical instance would need to be created. This is circular and prone to false positives. Consequently, the testing framework also defines a pair of class templates that complement <a class="el" href="../../da/dc4/structsequoia_1_1testing_1_1value__checker.html#value_checker_primary">value_checker</a>: <a class="el" href="../../d2/d52/structsequoia_1_1testing_1_1equivalence__checker.html#equivalence_checker_primary">equivalence_checker</a> and <a class="el" href="../../df/dff/structsequoia_1_1testing_1_1weak__equivalence__checker.html#weak_equivalence_checker_primary">weak_equivalence_checker</a>. We may consider a value for std::vector to be equivalent to an initializer_list in the sense that they hold (at the relevant point of the program) the same elements. Thus, a specialization equivalence_checker&lt;vector, initializer_list&gt; is supplied. Of course, there is more to a vector than the values it holds: there is the entire allocator framework too. In this case, however, it is not part of the logical structure and, indeed, the state of the allocator is not considered in vector::operator==. Thus it is philosophically reasonable to consider equivalence of vector and initializer_list. However, sometimes is is useful to check the equivalence of the state of an instance of T to a proper subset of the logical state of an instance of some S. For this purpose, the class template <a class="el" href="../../df/dff/structsequoia_1_1testing_1_1weak__equivalence__checker.html#weak_equivalence_checker_primary">weak_equivalence_checker</a> is supplied.</p>
<p>Both the <a class="el" href="../../d2/d52/structsequoia_1_1testing_1_1equivalence__checker.html#equivalence_checker_primary">equivalence_checker</a> and its weak counterpart can be fed &gt;=2 template type arguments. While for a vector we would just feed in two types (vector and initializer_list), in some cases we may need more. For example, a graph has both nodes and edges and so a graph may be considered equivalent to two types representing these structures. </p>
</div><h2 class="groupheader">Variable Documentation</h2>
<a id="a830946075c73f91cead550bbc0895e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830946075c73f91cead550bbc0895e0b">&#9670;&nbsp;</a></span>invocable_without_last_arg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sequoia::testing::impl::invocable_without_last_arg</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (<span class="keyword">sizeof</span>...(Args) &gt; 0) &amp;&amp; <a class="code" href="../../dd/da8/namespacesequoia_1_1testing.html#a9d81c642c83b1ef5c4c09a22c71dd9e2">requires</a>(Fn&amp;&amp; fn, Args&amp;&amp;... args) {</div>
<div class="line">      invoke_with_specified_args(fn, std::make_index_sequence&lt;<span class="keyword">sizeof</span>...(Args) - 1&gt;(), std::forward&lt;Args&gt;(args)...);</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacesequoia_1_1testing_html_a9d81c642c83b1ef5c4c09a22c71dd9e2"><div class="ttname"><a href="../../dd/da8/namespacesequoia_1_1testing.html#a9d81c642c83b1ef5c4c09a22c71dd9e2">sequoia::testing::requires</a></div><div class="ttdeci">requires(std::invocable&lt; Compare, T, T &gt;||sequoia::range&lt; T &gt;) bool dispatch_check(std</div><div class="ttdoc">The workhorse for performing a check with respect to a user-specified binary operator.</div><div class="ttdef"><b>Definition:</b> FreeCheckers.hpp:364</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
